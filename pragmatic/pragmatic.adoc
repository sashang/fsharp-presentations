:revealjs_theme: sky
:imagesdir: ./images
:source-highlighter: highlight.js
= F#

Real world use cases

== Yep, that's me....


[.notes]
--
https://stackoverflow.com/questions/23680778/how-do-you-open-a-file-from-within-vim/23680800#23680800
--

== Goal

* How to make your life 10% better

== Async

* Back in the day I was writing code like this:

[.notes]
--
In the mid 2000s I was writing code like this.
Inversion of control
Shared state
--

[source, c]
----
#include <stdio.h>

// Define the callback function type
typedef void (*CallbackFunction)(Downloads result);

void perform_download(char*[] urls, CallbackFunction callback) {
    // Perform blocking IO operation
    Downloads result = download(urls)

    // Call the callback function with the result
    callback(result);
}

void process_download_results(Downloads result) {
    // do something with the results
}

int main() {
    perform_download(urls, process_download_results);

    return 0;
}
----

== Async

* The question we want to answer is this

[source, c]
----
int main() {
    perform_download(urls, process_download_results);
    // how to handle the result here? <<1>>
    .
    .
    .
    .

}
----

1. How do we process the result of the download in the main function?

== Async When?

[%steps]
* Go coroutines - 2012
* JavaScript Promises - 2015
* C# async/await - 2012
* Python async/await - 2015
* Java CompletableFuture - 2015
* F# async/await - 2007
* Erlang was released in 1986

== Async

[source, fs]
----
let downloadAsync (url: string) =
    async {
        let! response = httpClient.GetAsync(url) |> Async.AwaitTask
        let! content = response.Content.ReadAsStringAsync() |> Async.AwaitTask
        return content
    }
----

== Async

* Closures
* Immutability

== Async caveats

[source, fsharp, linenums, highlight=3..5]
----
let downloadAll =
    let results = [
        for url in urls do
            let! result = donwloadAsync url <1>
            result
    ]
    results
----

<1> The use of let col in sequence expression is not permitted.

Sequence expressions are also computation expressions

image::coder_staring_at_a_screen_frustrated.png[]

== Async

[source,fsharp,linenums, highlight=4]
----
let downloadAll =
    let results = [
        for url in urls do
            let result = downloadAsync url
            result
    ]
    results |> Async.Parallel
----

== Async

* Use asyncSeq

[source,fsharp,linenums]
----
let downloadAll2 =
    asyncSeq {
        for url in urls do
            let! result = downloadAsync url
            result
    }
downloadAll2 |> AsyncSeq.toArrayAsync |> Async.RunSynchronously
----

== Type Providers

* Type providers are a way to generate types at compile time
* Made integration with a vendors xml based interface file a breeze

== Type Providers

[source,xml,linenums]
----
<books>
  <book id="1">
    <title>Programming F#</title>
    <author>Chris Smith</author>
    <year>2010</year>
  </book>
  <book id="2">
    <title>Expert F# 4.0</title>
    <author>Don Syme</author>
    <year>2015</year>
  </book>
</books>
----

== Type Providers

[source,fs,linenums]
----
#r "nuget: FSharp.Data"

open FSharp.Data

type Books = XmlProvider<"books.xml">

let data = Books.Load("books.xml")

for book in data.Books do
    printfn "%s" book.Title
----

== Domain Driven Design

* Model the business domain with the type system
* Make illegal states unrepresentable
* Shared model for communication between BA and developers
* Not class driven
* Not database driven

== Domain Driven Design

* Separate the domain objects from the DTO objects
* No nulls in F# but real world is messy

== REST

* No nulls

== Hurdles

* Immutability
* Strange looks
* Corporate culture

== Stinky bits

* array syntax

[source,fs]
----
let x = [1; 2; 3]
let y = [|1; 2; 3|]

let foo (x: int[]) = x
foo x
----


== Stinky bits

[source,fs]
----
let y = [|1; 2; 3|]
y.[1]
----

== Stinky bits

[source,fs]
----
let apply x y = x y

let bar y =
    apply id y
----

== Stinky bits

[source,fs]
----
let apply x y = x y

let bar y =
    apply id
----

== How to use <your favourite language> in your organization

* Make a case for it.
* Fundamentally businesses don't care how you get the result.

[%auto-animate]
== Insert <your favourite language>

.Language comparison matrix
|===
|                |Java | Go  | Javascript | C#  | Python | F#  |
|Web Development |Yes  | Yes | Yes        | Yes | Yes    | Yes |
|===

[%auto-animate]
== Insert <your favourite language>

.Language comparison matrix
|===
|                |Java | Go  | Javascript | C#  | Python | F#  | C++
|Web Development |Yes  | Yes | Yes        | Yes | Yes    | Yes |
|Numerics        |Yes  | Yes | No         | Yes | No     | Yes | Yes
|===

[%auto-animate]
== Insert <your favourite language>

.Language comparison matrix
|===
|                |Java | Go  | C#  | F#
|Web Development |Yes  | Yes | Yes | Yes
|Numerics        |Yes  | Yes | Yes | Yes
|Type System     |Yes  | No  | Yes | Yes
|===

[%auto-animate]
== Insert <your favourite language>

.Language comparison matrix
|===
|                |Java | C#  | F#
|Web Development |Yes  | Yes | Yes
|Numerics        |Yes  | Yes | Yes
|Type System     |Yes  | Yes | Yes
|CTO hates oracle|No   | Yes | Yes
|===

[%auto-animate]
== Insert <your favourite language>

.Language comparison matrix
|===
|                | C#  | F#
|Web Development | Yes | Yes
|Numerics        | Yes | Yes
|Type System     | Yes | Yes
|CTO hates oracle| Yes | Yes
|Domain modelling| No | Yes
|===

[%auto-animate]
== Insert F#

.Language comparison matrix
|===
|                |  F#
|Web Development |  Yes
|Numerics        |  Yes
|Type System     |  Yes
|CTO hates oracle|  Yes
|Domain modelling|  Yes
|===
